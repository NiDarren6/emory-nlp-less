gold,pred,exec,esm+norules,esm+rules,category,True equivalence,Notes
"SELECT CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) AS ratio FROM customers	debit_card_specializing",SELECT cast(sum(CASE WHEN currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / sum(CASE WHEN currency = 'CZK' THEN 1 ELSE 0 END) FROM customers,1,0,0,yellow,1,"FLOAT type holds the same affinity as REAL 
https://www.sqlite.org/datatype3.html"
"SELECT SUM(IIF(T1.Currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.Currency = 'EUR', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2012'	debit_card_specializing","SELECT sum(CASE WHEN customers.currency = 'CZK' THEN yearmonth.consumption ELSE 0 END) - sum(CASE WHEN customers.currency = 'EUR' THEN yearmonth.consumption ELSE 0 END) FROM customers INNER JOIN yearmonth ON customers.customerid = yearmonth.customerid WHERE substr(yearmonth.date, 1, 4) = '2012'",1,0,0,yellow,1,Aliases & IIF
SELECT SUM(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'	debit_card_specializing,"SELECT sum(yearmonth.consumption) FROM customers INNER JOIN yearmonth ON customers.customerid = yearmonth.customerid WHERE customers.customerid = 6 AND substr(yearmonth.date, 1, 4) = '2013' AND substr(yearmonth.date, 5, 2) BETWEEN '08' AND '11'",1,0,0,yellow,1,Only true if yearmonth's customerid is a FK of customers' customerid
"SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'	debit_card_specializing",SELECT sum(CASE WHEN gasstations.country = 'CZE' THEN 1 ELSE 0 END) - sum(CASE WHEN gasstations.country = 'SVK' THEN 1 ELSE 0 END) FROM gasstations WHERE gasstations.segment = 'Discount',1,0,0,yellow,1, IIF = CASE WHEN
"SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'	debit_card_specializing",SELECT cast(sum(CASE WHEN consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / count(customerid) FROM yearmonth WHERE date LIKE '201202%',1,0,0,yellow,0,"WHERE clause is wrong. '=' vs LIKE: would not be equal for full dates, '=' only covers partial results"
SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00	debit_card_specializing,SELECT count(yearmonth.customerid) FROM customers INNER JOIN yearmonth ON customers.customerid = yearmonth.customerid WHERE customers.currency = 'EUR' AND yearmonth.consumption > 1000,1,0,0,yellow,1,Inner join
SELECT DISTINCT T3.Description FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Country = 'CZE'	debit_card_specializing,SELECT DISTINCT products.description FROM gasstations INNER JOIN transactions_1k ON gasstations.gasstationid = transactions_1k.gasstationid INNER JOIN products ON transactions_1k.productid = products.productid WHERE gasstations.country = 'CZE',1,0,0,yellow,1,minor reordering
SELECT DISTINCT T1.Time FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11	debit_card_specializing,SELECT DISTINCT transactions_1k.time FROM gasstations INNER JOIN transactions_1k ON gasstations.gasstationid = transactions_1k.gasstationid WHERE gasstations.chainid = 11,1,0,0,yellow,1,minor reordering
"SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND STRFTIME('%Y', T1.Date) >= '2012'	debit_card_specializing",SELECT count(transactions_1k.transactionid) FROM gasstations INNER JOIN transactions_1k ON gasstations.gasstationid = transactions_1k.gasstationid WHERE gasstations.country = 'CZE' AND transactions_1k.`date` > '2012-01-01',1,0,0,yellow,1,STRFTIME = date logic
SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.date = '2012-08-23' AND T1.time = '21:20:00'	debit_card_specializing,SELECT customers.segment FROM customers INNER JOIN transactions_1k ON customers.customerid = transactions_1k.customerid WHERE transactions_1k.`date` = '2012-08-23' AND transactions_1k.`time` = '21:20:00',1,0,0,yellow,1,Join order reversed
SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'	debit_card_specializing,SELECT count(transactions_1k.transactionid) FROM transactions_1k INNER JOIN gasstations ON transactions_1k.gasstationid = gasstations.gasstationid WHERE gasstations.country = 'CZE' AND transactions_1k.`date` = '2012-08-26' AND transactions_1k.time BETWEEN '08:00:00' AND '09:00:00',1,0,0,yellow,1,identical logic
"SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'	debit_card_specializing",SELECT cast(sum(CASE WHEN customers.currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / count(customers.customerid) FROM customers INNER JOIN transactions_1k ON customers.customerid = transactions_1k.customerid WHERE transactions_1k.`date` = '2012-08-25',1,0,0,yellow,1,IFF & CASE
"SELECT CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations	debit_card_specializing",SELECT cast(sum(CASE WHEN gasstations.segment = 'Premium' THEN 1 ELSE 0 END) AS REAL) * 100 / count(gasstations.gasstationid) FROM gasstations WHERE gasstations.country = 'SVK',1,0,0,yellow,0,Second query does not filter numerator by country
SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'	student_club,SELECT major.major_name FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE member.first_name = 'Angela' AND member.last_name = 'Sanders',1,0,0,yellow,1,alias.  
SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'	student_club,SELECT count(member.member_id) FROM member INNER JOIN attendance ON member.member_id = attendance.link_to_member INNER JOIN event ON attendance.link_to_event = event.event_id WHERE event.event_name = 'Women''s Soccer' AND member.t_shirt_size = 'Medium',1,0,0,yellow,1,Join gives same results for quering on different joined IDs
SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'	student_club,SELECT sum(income.amount) FROM income INNER JOIN member ON income.link_to_member = member.member_id WHERE member.position = 'Vice President',1,0,0,yellow,0,"First query selects individual amounts, second sums amounts"
SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'	student_club,SELECT notes FROM income WHERE date_received = '2019-09-14' AND source = 'Fundraising',1,0,0,yellow,1,Different ordering of conditions in WHERE
SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs'	student_club,SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs',1,0,0,yellow,1,identical logic
"SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'	student_club","SELECT budget.event_status FROM budget INNER JOIN expense ON budget.budget_id = expense.link_to_budget WHERE expense.expense_date = '2019-08-20' AND expense.expense_description = 'Post Cards, Posters'",1,0,0,yellow,1,alias
SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'	student_club,SELECT major.major_name FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE member.first_name = 'Brent' AND member.last_name = 'Thomason',1,0,0,yellow,1,alias
SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'	student_club,SELECT count(member.member_id) FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE major.major_name = 'Business' AND member.t_shirt_size = 'Medium',1,0,0,yellow,1,alias
SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'President'	student_club,SELECT major.department FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE member.position = 'President',1,0,0,yellow,1,same table structure and joins
SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Connor' AND T1.last_name = 'Hilton' AND T2.source = 'Dues'	student_club,SELECT income.date_received FROM member INNER JOIN income ON member.member_id = income.link_to_member WHERE member.first_name = 'Connor' AND member.last_name = 'Hilton' AND income.source = 'Dues',1,0,0,yellow,1,same logic
SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza'	student_club,SELECT sum(expense.cost) FROM expense INNER JOIN budget ON expense.link_to_budget = budget.budget_id WHERE expense.expense_description = 'Pizza',1,0,0,yellow,0,Second query adds a join
SELECT COUNT(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia'	student_club,SELECT count(city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia',1,0,0,yellow,1,identical
SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.phone = '809-555-3360'	student_club,SELECT major.major_name FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE member.phone = '809-555-3360',1,0,0,yellow,1,same logic
SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'	student_club,SELECT count(attendance.link_to_member) FROM event INNER JOIN attendance ON event.event_id = attendance.link_to_event WHERE event.event_name = 'Women''s Soccer',1,0,0,yellow,1,alias
"SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'	student_club","SELECT member.first_name, member.last_name FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE major.department = 'School of Applied Sciences, Technology and Education'",1,0,0,yellow,1,alias
SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1	student_club,SELECT event.event_name FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE budget.event_status = 'Closed' ORDER BY budget.spent / budget.amount DESC LIMIT 1,1,0,0,yellow,0,Non-equal if status and event_status has different values
SELECT MAX(spent) FROM budget	student_club,SELECT max(budget.spent) FROM budget INNER JOIN event ON budget.link_to_event = event.event_id,1,0,0,yellow,0,INNER JOIN filters rows with no corresponding event
"SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7	student_club","SELECT member.first_name, member.last_name FROM attendance INNER JOIN member ON attendance.link_to_member = member.member_id GROUP BY member.first_name, member.last_name HAVING count(member.first_name) > 7",1,0,0,yellow,0,"First query is more accurate by using unique link_to_member identifier, second one groups by first and last name, can cause issues if 2 members have the same name"
SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1	student_club,SELECT event.event_name FROM expense INNER JOIN budget ON expense.link_to_budget = budget.budget_id INNER JOIN event ON budget.link_to_event = event.event_id ORDER BY expense.cost ASC LIMIT 1,1,0,0,yellow,1,same joins and orders
SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) AS REAL) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget	student_club,SELECT cast(sum(CASE WHEN event.event_name = 'Yearly Kickoff' THEN expense.cost ELSE 0 END) AS REAL) * 100 / sum(expense.cost) FROM budget INNER JOIN expense ON budget.budget_id = expense.link_to_budget INNER JOIN event ON budget.link_to_event = event.event_id,1,0,0,yellow,1,same conditionals and joins
SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' and '2019-09-30' ORDER BY source DESC LIMIT 1	student_club,"SELECT source FROM income WHERE strftime('%Y-%m', date_received) = '2019-09' GROUP BY source ORDER BY sum(amount) DESC LIMIT 1",1,0,0,yellow,0,"Second query groups by source then orders by sum, so it considers the sum of income amounts rather than just ordering by source"
SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Physics Teaching'	student_club,SELECT count(member.member_id) FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE major.major_name = 'Physics Teaching',1,0,0,yellow,1,alias
SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' ORDER BY T1.spent DESC LIMIT 1	student_club,SELECT event.event_name FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE budget.category = 'Advertisement' ORDER BY budget.spent DESC LIMIT 1,1,0,0,yellow,1,same join and odering logic
SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Posters'	student_club,SELECT sum(expense.cost) FROM budget INNER JOIN event ON budget.link_to_event = event.event_id INNER JOIN expense ON budget.budget_id = expense.link_to_budget WHERE event.event_name = 'September Speaker' AND expense.expense_description = 'Posters',1,0,0,yellow,0,"First query returns individual cost values, second query returns sum of cost values"
SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20'	student_club,SELECT sum(cost) FROM expense WHERE expense_date = '2019-08-20',1,0,0,yellow,1,Capitalization 
"SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'	student_club","SELECT member.first_name, member.last_name, sum(expense.cost) FROM member INNER JOIN expense ON member.member_id = expense.link_to_member WHERE expense.link_to_member = 'rec4BLdZHS2Blfp4v' GROUP BY member.first_name, member.last_name",1,0,0,yellow,1,alias and GROUP BY
SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'	student_club,SELECT expense.expense_description FROM member INNER JOIN expense ON member.member_id = expense.link_to_member WHERE member.first_name = 'Sacha' AND member.last_name = 'Harrison',1,0,0,yellow,1,alias
"SELECT T2.last_name, T1.department, T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'	student_club","SELECT member.last_name, major.department, major.college FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE major.major_name = 'Environmental Engineering'",1,0,0,yellow,0,First query has additional filtering for T2.position = 'Member'
SELECT CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) AS REAL) * 100 / COUNT(T2.income_id) FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium'	student_club,SELECT cast(sum(CASE WHEN income.amount = 50 THEN 1 ELSE 0 END) AS REAL) * 100 / count(member.member_id) FROM income INNER JOIN member ON income.link_to_member = member.member_id WHERE member.t_shirt_size = 'Medium',1,0,0,yellow,0,First query has additional filtering for T1.position = 'Member'
"SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'	student_club","SELECT member.first_name, member.last_name, income.amount FROM income INNER JOIN member ON income.link_to_member = member.member_id WHERE income.date_received = '2019-09-09'",1,0,0,yellow,1,Second query just more simplified
"SELECT T1.Diagnosis, T2.Date FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 30609	thrombosis_prediction","SELECT patient.diagnosis, laboratory.date FROM patient INNER JOIN laboratory ON patient.id = laboratory.id WHERE patient.id = 30609",1,0,0,yellow,1,alias
"SELECT  COUNT(*) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND STRFTIME('%Y', T2.`Examination Date`) = '1997' AND T2.Thrombosis = 1	thrombosis_prediction","SELECT count(patient.id) FROM examination INNER JOIN patient ON examination.id = patient.id WHERE strftime('%Y', examination.`examination date`) = '1997' AND examination.thrombosis = 1 AND patient.sex = 'F'",1,0,0,yellow,1,
SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')	thrombosis_prediction,SELECT count(examination.id) FROM examination INNER JOIN patient ON examination.id = patient.id WHERE examination.thrombosis = 2 AND examination.`ana pattern` = 'S' AND examination.`acl igm` > ( SELECT avg(`acl igm`) FROM examination ),1,0,0,yellow,0,"First queries multiples average by 1.2, second query adds a join"
SELECT AVG(T2.ALB) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 400 AND T1.Diagnosis = 'SLE' AND T1.SEX = 'F'	thrombosis_prediction,SELECT avg(laboratory.alb) FROM patient INNER JOIN laboratory ON patient.id = laboratory.id WHERE patient.sex = 'F' AND patient.diagnosis = 'SLE' AND laboratory.plt > 400,1,0,0,yellow,1,functionally identical
SELECT COUNT(ID) FROM Patient WHERE SEX = 'F' AND Diagnosis = 'APS'	thrombosis_prediction,SELECT count(id) FROM patient WHERE diagnosis = 'APS' AND sex = 'F',1,0,0,yellow,1,Reordering of condtions and capitalization in WHERE does not affect result
"SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70	thrombosis_prediction",SELECT count(id) FROM laboratory WHERE cre < 70 AND centromea = 'negative',1,0,0,yellow,0,"1. distinct keyword eliminates rows (laboratory.id needs to be unique, not null)
2. where clause checks different conditions (cre >= 1.5 vs. cre < 70)
3. need laboratory.id be a FK of patient.id"
"SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'	thrombosis_prediction",SELECT count(patient.id) FROM patient INNER JOIN laboratory ON patient.id = laboratory.id WHERE laboratory.centromea = 0 AND laboratory.ssb = 0 AND patient.sex = 'M',1,0,0,yellow,0,"1. distinct keyword eliminates rows (patient.id and laboratory.id need to be unique, not null)
2. where clause is broader than it should be (centromea and ssb should not be 'negative')"
SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'	european_football_2,SELECT avg(player_attributes.long_shots) FROM player INNER JOIN player_attributes ON player.player_api_id = player_attributes.player_api_id WHERE player.player_name = 'Ahmed Samir Farag',1,0,0,yellow,0,1. player_attributes.long_shots and player_attributes.date need to be not null
SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0	european_football_2,SELECT DISTINCT league.name FROM league INNER JOIN MATCH ON league.id = MATCH.league_id WHERE MATCH.season = '2009/2010' AND MATCH.home_team_goal > MATCH.away_team_goal,1,0,0,yellow,0,"1. having clause does not consider leagues when at least one match has home_team_goal > away_team_goal 
2. group by vs distinct is okay"
"SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'	european_football_2",SELECT player_name FROM player WHERE birthday LIKE '1970-10%',1,0,0,yellow,1,"1. substr(column, start, len) is inclusive of start and end indices (start at 1)"
"SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Gabriel Tamas' AND strftime('%Y', t2.date) = '2011'	european_football_2",SELECT player_attributes.overall_rating FROM player INNER JOIN player_attributes ON player.player_api_id = player_attributes.player_api_id WHERE player.player_name = 'Gabriel Tamas' AND player_attributes.`date` LIKE '2011%',1,0,0,yellow,1,1. true IFF player_attributes.date is in a valid date format
SELECT CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Poland' AND t2.season = '2010/2011'	european_football_2,SELECT avg(match.home_team_goal) FROM match INNER JOIN country ON match.country_id = country.id WHERE country.name = 'Poland' AND match.season = '2010/2011',1,0,0,yellow,0,1. match.home_team_goal and match.id need to be not null  
SELECT player_name FROM Player ORDER BY height DESC LIMIT 1	european_football_2,SELECT player_name FROM player ORDER BY height DESC LIMIT 1,1,0,0,yellow,1,1. table capitalization does not matter
SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'	european_football_2,SELECT count(player.player_name) FROM player INNER JOIN player_attributes ON player.player_api_id = player_attributes.player_api_id WHERE player_attributes.preferred_foot = 'left' AND player_attributes.attacking_work_rate = 'low',1,0,0,yellow,0,"1. player_attributes.player_api_id need to be FK of player.player_api_id
2. each of player.player_name and player.player_api_id needs to be unique, not null"
"SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND SUBSTR(t2.`date`, 1, 7) = '2009-04'	european_football_2",SELECT count(match.id) FROM match INNER JOIN league ON match.league_id = league.id WHERE league.name = 'Belgium Jupiler League' AND match.date LIKE '2009-04%',1,0,0,yellow,1,same case as row#54
SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id	european_football_2,SELECT cast((sum(CASE WHEN player.player_name = 'Ariel Borysiuk' THEN player_attributes.overall_rating ELSE 0 END) - sum(CASE WHEN player.player_name = 'Paulin Puel' THEN player_attributes.overall_rating ELSE 0 END)) AS REAL) * 100 / sum(CASE WHEN player.player_name = 'Paulin Puel' THEN player_attributes.overall_rating ELSE 0 END) FROM player INNER JOIN player_attributes ON player.player_api_id = player_attributes.player_api_id,1,0,0,yellow,1,"1. the difference is between integers, so casting as real before or after are equivalent"
SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Pietro Marino'	european_football_2,SELECT avg(player_attributes.overall_rating) FROM player INNER JOIN player_attributes ON player.player_api_id = player_attributes.player_api_id WHERE player.player_name = 'Pietro Marino',1,0,0,yellow,0,1. player_attributes.overall_rating and player_attributes.id need to be not null
"SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Ajax' ORDER BY t2.chanceCreationPassing DESC LIMIT 1	european_football_2","SELECT max(team_attributes.chancecreationpassing), team_attributes.chancecreationpassingclass FROM team INNER JOIN team_attributes ON team.team_api_id = team_attributes.team_api_id WHERE team.team_long_name = 'Ajax'",1,0,0,yellow,1 (probably),1. max is same as desc limit 1 (team_attributes.chancecreationpassing should not  be a column of all nulls)
"SELECT player_name FROM (SELECT player_name, height, DENSE_RANK() OVER (ORDER BY height DESC) as rank FROM Player) WHERE rank = 1	european_football_2",SELECT player_name FROM player ORDER BY height DESC LIMIT 1,1,0,0,yellow,0,"1. (highest player's) height needs to be unique (dense rank returns same rank for same rows)
2. (player.height should not be a column of all nulls)"
SELECT COUNT(t1.id) FROM Player_Attributes AS t1 WHERE t1.preferred_foot = 'left' AND t1.crossing = ( SELECT MAX(crossing) FROM Player_Attributes)	european_football_2,SELECT count(player_api_id) FROM player_attributes WHERE preferred_foot = 'left' AND crossing = ( SELECT max(crossing) FROM player_attributes ),1,0,0,yellow,0,1. player_attributes.id and player_attributes.player_api_id are not null
SELECT DISTINCT t1.buildUpPlaySpeedClass FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.team_long_name = 'KSV Cercle Brugge'	european_football_2,SELECT DISTINCT team_attributes.buildupplayspeedclass FROM team INNER JOIN team_attributes ON team.team_api_id = team_attributes.team_api_id WHERE team.team_long_name = 'KSV Cercle Brugge',1,0,0,yellow,1,1. capitalization does not matter for table columns
SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' GROUP BY t1.name ORDER BY COUNT(t2.id) DESC LIMIT 4	european_football_2,SELECT league.name FROM league INNER JOIN MATCH ON league.id = MATCH.league_id WHERE MATCH.season = '2015/2016' GROUP BY league.name ORDER BY count(MATCH.id) DESC LIMIT 4,1,0,0,yellow,1,1. using alias okay
SELECT t2.team_long_name FROM Match AS t1 INNER JOIN Team AS t2 ON t1.away_team_api_id = t2.team_api_id ORDER BY t1.away_team_goal DESC LIMIT 1	european_football_2,SELECT team.team_long_name FROM team INNER JOIN MATCH ON team.team_api_id = MATCH.away_team_api_id ORDER BY MATCH.away_team_goal DESC LIMIT 1,1,0,0,yellow,1,1. using alias okay
SELECT CAST(COUNT(CASE WHEN t2.overall_rating > 70  AND t1.height < 180 THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id 	european_football_2,SELECT cast(sum(CASE WHEN player.height < 180 AND player_attributes.overall_rating > 70 THEN 1 ELSE 0 END) AS REAL) * 100 / count(*) FROM player INNER JOIN player_attributes ON player.player_api_id = player_attributes.player_api_id,1,0,0,yellow,1,"1. count(id) and sum(1) are equivalent 
2. player.id needs to be not null (actually is PK so is okay)
3. result column renaming also okay"
SELECT COUNT(T3.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2007 AND T1.name = 'Bahrain Grand Prix' AND T2.time IS NULL	formula_1,SELECT count(results.driverid) FROM races INNER JOIN results ON races.raceid = results.raceid WHERE races.name = 'Bahrain Grand Prix' AND races.year = 2007 AND results.statusid != 1,1,0,0,yellow,0,"1. where clause is wrong (results.time vs results.statusid)
2. need results.driverid to be a FK for drivers.driverid
3. drivers.driverid is not null"
SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901	formula_1,SELECT seasons.url FROM races INNER JOIN seasons ON races.year = seasons.year WHERE races.raceid = 901,1,0,0,yellow,1,1. using alias okay
SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId ORDER BY T2.fastestLapSpeed DESC LIMIT 1	formula_1,SELECT nationality FROM drivers WHERE driverid = ( SELECT driverid FROM results ORDER BY fastestlapspeed DESC LIMIT 1 ),1,0,0,yellow,1 (probably),"1. need results.driverid to be a FK for drivers.driverid
2. drivers.driverid is PK
3. results.fastestlapspeed should not be a column of all nulls"
SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'	formula_1,SELECT cast(sum(CASE WHEN results.statusid = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / count(results.raceid) FROM results INNER JOIN races ON results.raceid = races.raceid WHERE races.date = '1983-07-16',1,0,0,yellow,0,"1. condition in case is not correct (results.statusid vs results.time)
2. count(id) is equivalent to sum(1) so that is okay
3. need results.driverid and results.raceid to be not null"
SELECT AVG(T2.milliseconds) FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.year = 2009 AND T1.name = 'Malaysian Grand Prix'	formula_1,SELECT avg(laptimes.milliseconds) FROM races INNER JOIN laptimes ON races.raceid = laptimes.raceid INNER JOIN drivers ON laptimes.driverid = drivers.driverid WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' AND races.name = 'Malaysian Grand Prix' AND races.year = 2009,1,0,0,yellow,1,1. using alias okay
"SELECT DISTINCT T2.name, T1.name, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2005 AND STRFTIME('%m', T2.date) = '09'	formula_1","SELECT races.name, circuits.name, circuits.location FROM races INNER JOIN circuits ON races.circuitid = circuits.circuitid WHERE strftime('%Y-%m', races.date) = '2005-09' AND races.name LIKE '%Grand Prix%'",1,0,0,yellow,0,"1. distinct keyword could delete rows in result
2. where clause is different (races.name LIKE '%Grand Prix%')
3. races.year needs to be consistent with strftime('%Y', races.date)"
SELECT CAST(COUNT(CASE WHEN T1.country = 'Germany' THEN T2.circuitID END) AS REAL) * 100 / COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix'	formula_1,SELECT cast(sum(CASE WHEN circuits.country = 'Germany' THEN 1 ELSE 0 END) AS REAL) * 100 / count(races.raceid) FROM races INNER JOIN circuits ON races.circuitid = circuits.circuitid WHERE races.name = 'European Grand Prix',1,0,0,yellow,1,"1. count(id) and sum(1) are equivalent 
2. circuits.circuitid needs to be not null (actually is PK so is okay) 
3. races.raceid needs to be not null (actually is PK too so is okay)"
"SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit'	formula_1","SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit'",1,0,0,yellow,1,
SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit'	formula_1,SELECT circuitref FROM circuits WHERE name = 'Marina Bay Street Circuit',1,0,0,yellow,1,1. capitalization does not matter for table columns
SELECT T2.positionOrder FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.name = 'Chinese Grand Prix' AND T1.year = 2008	formula_1,SELECT results.rank FROM races INNER JOIN results ON races.raceid = results.raceid INNER JOIN drivers ON results.driverid = drivers.driverid WHERE races.name = 'Chinese Grand Prix' AND races.year = 2008 AND drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton',1,0,0,yellow,0,1. selecting wrong column (results.positionorder vs results.rank) would probably never be okay unless two columns are equal
SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )	formula_1,SELECT count(results.driverid) FROM races INNER JOIN results ON races.raceid = results.raceid WHERE races.name = 'Chinese Grand Prix' AND races.year = 2008 AND results.statusid = 1,1,0,0,yellow,0,"1. where clause is wrong (results.time vs results.statusid)
2. races.raceid is not null (actually PK so is okay)
3. having clause is okay. each driverid will have at least one not null entry in races due to inner join
4. results.driverid is not null"
"WITH time_in_seconds AS ( SELECT T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6) AS REAL) ELSE CAST(SUBSTR(T1.time, 2) AS REAL) END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL AND T2.year = 2008 ), champion_time AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = 1), last_driver_incremental AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds) ) SELECT (CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)	formula_1",SELECT cast(sum(CASE WHEN results.position = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / count(results.resultid) FROM races INNER JOIN results ON races.raceid = results.raceid WHERE races.name = 'Australian Grand Prix' AND races.year = 2008,1,0,0,yellow,0,COMPLETELY WRONG QUERY! time percentage vs position percentage
SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia'	formula_1,SELECT count(circuitid) FROM circuits WHERE country = 'Australia' AND LOCATION = 'Adelaide',1,0,0,yellow,1,1. capitalization does not matter for table columns
SELECT AVG(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'	formula_1,SELECT avg(results.fastestlapspeed) FROM races INNER JOIN results ON races.raceid = results.raceid WHERE races.name = 'Spanish Grand Prix' AND races.year = 2009,1,0,0,yellow,1,1. capitalization does not matter for table columns
SELECT code FROM drivers WHERE Nationality = 'American'	formula_1,SELECT code FROM drivers WHERE nationality = 'American',1,0,0,yellow,1,1. capitalization does not matter for table columns
SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1	formula_1,SELECT driverref FROM drivers WHERE nationality = 'German' ORDER BY dob ASC LIMIT 1,1,0,0,yellow,1 (probably),1. okay as long as dob is stored in a format that SQLite recognizes as a date
"SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3	formula_1","SELECT drivers.forename, drivers.surname FROM drivers INNER JOIN pitstops ON drivers.driverid = pitstops.driverid WHERE drivers.nationality = 'German' AND strftime('%Y', drivers.dob) BETWEEN '1980' AND '1985' GROUP BY drivers.driverid ORDER BY avg(pitstops.duration) LIMIT 3",1,0,0,yellow,1 (maybe?),"1. group by columns are wrong, but is using PK instead of (forename, surname), which is okay if they are not null and together unique"
"SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'	formula_1","SELECT constructors.constructorref, constructors.url FROM results INNER JOIN constructors ON results.constructorid = constructors.constructorid INNER JOIN races ON results.raceid = races.raceid WHERE races.name = 'Singapore Grand Prix' AND races.year = 2009 AND results.position = 1",1,0,0,yellow,1 (maybe?),1. where clause is wrong but position=1 is synonymous to time like '_:%:__.___' for this particular db
SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = '3-D Man'	superhero,SELECT superpower.power_name FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superhero.superhero_name = '3-D Man',1,0,0,yellow,1,1. using alias okay
"SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1	formula_1","SELECT drivers.forename, drivers.surname FROM drivers INNER JOIN qualifying ON drivers.driverid = qualifying.driverid INNER JOIN races ON qualifying.raceid = races.raceid INNER JOIN circuits ON races.circuitid = circuits.circuitid WHERE circuits.name = 'Marina Bay Street Circuit' AND races.year = 2008 AND qualifying.position = 1",1,0,0,yellow,1 (maybe?),"1. need races.circuitid to be a FK for circuits.circuitid
2. the qualify.position=1 is okay if it is defined on best time on q3"
"SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1	formula_1","SELECT drivers.forename, drivers.surname, drivers.nationality, races.name FROM drivers INNER JOIN driverstandings ON drivers.driverid = driverstandings.driverid INNER JOIN races ON driverstandings.raceid = races.raceid ORDER BY drivers.dob DESC LIMIT 1",1,0,0,yellow,1 (probably),same case as row#84
SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.height_cm > 200	superhero,SELECT count(superhero.id) FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Super Strength' AND superhero.height_cm > 200,1,0,0,yellow,1,1. using alias okay
SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id WHERE T3.power_name = 'Agility' AND T4.colour = 'Blue'	superhero,SELECT count(superhero.id) FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id INNER JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'Blue' AND superpower.power_name = 'Agility',1,0,0,yellow,1,1. using alias okay
SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)	superhero,SELECT superhero.superhero_name FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE publisher.publisher_name = 'Marvel Comics' AND superpower.power_name = 'Super Strength',1,0,0,yellow,0,"1. SELECT 1 to check hero_power not null
2. INNER JOIN and EXISTS achieve same logic here

EXISTS clause from gold checks the same conditions as INNER JOIN on pred

but power_name is not unique in superpower"
SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.colour = 'Gold'	superhero,SELECT count(superhero.id) FROM publisher INNER JOIN superhero ON publisher.id = superhero.publisher_id INNER JOIN colour ON superhero.eye_colour_id = colour.id WHERE publisher.publisher_name = 'Marvel Comics' AND colour.colour = 'Gold',1,0,0,yellow,1,alias
SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'Copycat'	superhero,SELECT race.race FROM superhero INNER JOIN race ON superhero.race_id = race.id WHERE superhero.superhero_name = 'Copycat',1,0,0,yellow,1,alias
SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)	superhero,SELECT superhero.superhero_name FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Durability' AND hero_attribute.attribute_value < 50,1,0,0,yellow,0,same as 92
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'	superhero,SELECT superhero.superhero_name FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Death Touch',1,0,0,yellow,1,alias
SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.attribute_name = 'Strength' AND T2.attribute_value = 100 AND T4.gender = 'Female'	superhero,SELECT count(superhero.id) FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id INNER JOIN gender ON superhero.gender_id = gender.id WHERE gender.gender = 'Female' AND attribute.attribute_name = 'Strength' AND hero_attribute.attribute_value = 100,1,0,0,yellow,1,alias
SELECT id FROM publisher WHERE publisher_name = 'Star Trek'	superhero,SELECT id FROM publisher WHERE publisher_name = 'Star Trek',1,0,0,yellow,1,Exact string match
SELECT COUNT(id) FROM superhero WHERE full_name IS NULL	superhero,SELECT count(id) FROM superhero WHERE full_name IS NULL,1,0,0,yellow,1,capitalization
SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'	superhero,SELECT avg(superhero.weight_kg) FROM superhero INNER JOIN gender ON superhero.gender_id = gender.id WHERE gender.gender = 'Female',1,0,0,yellow,1,alias
SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5	superhero,SELECT superpower.power_name FROM superhero INNER JOIN gender ON superhero.gender_id = gender.id INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE gender.gender = 'Male' LIMIT 5,1,0,0,yellow,0,same as 92
SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180	superhero,SELECT cast(sum(CASE WHEN publisher.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) * 100 / count(*) FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE superhero.height_cm BETWEEN 150 AND 180,1,0,0,yellow,1,"publisher_id is a foreign key, INNER JOIN is ok
"
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79	superhero,SELECT superhero.superhero_name FROM superhero INNER JOIN gender ON superhero.gender_id = gender.id WHERE gender.gender = 'Male' AND superhero.weight_kg > ( SELECT avg(weight_kg) * 0.79 FROM superhero ),1,0,0,yellow,0,"gold: weight * 100 > (avg(weight)) * 79

pred: weight > (avg(weight)) * 0.79

supppose average weight_kg of all superheroes is 120.

gold: (80 * 100) > (120 * 79) => 9480 > 7900

pred: 80 > (120 * 0.79) => 80 > 94.8 (WRONG!)"
SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1	superhero,SELECT superpower.power_name FROM hero_power INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE hero_power.hero_id = 1,1,0,0,yellow,1,hero_power power_id attr is a foreign key of superpower
SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'	superhero,SELECT count(hero_power.hero_id) FROM hero_power INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Stealth',1,0,0,yellow,1,alias
SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1	superhero,SELECT superhero.full_name FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Strength' ORDER BY hero_attribute.attribute_value DESC LIMIT 1,1,0,0,yellow,1,alias
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1	superhero,SELECT superhero.superhero_name FROM publisher INNER JOIN superhero ON publisher.id = superhero.publisher_id INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE publisher.publisher_name = 'Dark Horse Comics' AND attribute.attribute_name = 'Durability' ORDER BY hero_attribute.attribute_value DESC LIMIT 1,1,0,0,yellow,1,alias
"SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'	superhero","SELECT superhero.eye_colour_id, superhero.hair_colour_id, superhero.skin_colour_id FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id INNER JOIN gender ON superhero.gender_id = gender.id WHERE gender.gender = 'Female' AND publisher.publisher_name = 'Dark Horse Comics'",1,0,0,yellow,1,alias
SELECT COUNT(T1.power_id) FROM hero_power AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.superhero_name = 'Amazo'	superhero,SELECT count(hero_power.power_id) FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id WHERE superhero.superhero_name = 'Amazo',1,0,0,yellow,1,alias
SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'	superhero,SELECT superhero.height_cm FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'Amber',1,0,0,yellow,1,alias
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'	superhero,SELECT superhero.superhero_name FROM superhero INNER JOIN alignment ON superhero.alignment_id = alignment.id WHERE alignment.alignment = 'Neutral',1,0,0,yellow,1,alias
SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )	superhero,SELECT count(*) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Strength' AND hero_attribute.attribute_value = 100,1,0,0,yellow,0,
SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' AND T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) * 100 FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id	superhero,SELECT cast(sum(CASE WHEN gender.gender = 'Female' THEN 1 ELSE 0 END) AS REAL) * 100 / count(*) FROM publisher INNER JOIN superhero ON publisher.id = superhero.publisher_id INNER JOIN gender ON gender.id = superhero.gender_id WHERE publisher.publisher_name = 'Marvel Comics',1,0,0,yellow,,
SELECT ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky' ) - ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler' ) AS CALCULATE	superhero,SELECT weight_kg - ( SELECT weight_kg FROM superhero WHERE full_name = 'Charles Chandler' ) FROM superhero WHERE full_name = 'Emil Blonsky',1,0,0,yellow,1,order is ok here
SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Abomination'	superhero,SELECT superpower.power_name FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superhero.superhero_name = 'Abomination',1,0,0,yellow,1,alias
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1	superhero,SELECT superhero.superhero_name FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Speed' ORDER BY hero_attribute.attribute_value DESC LIMIT 1,1,0,0,yellow,1,alias
"SELECT T3.attribute_name, T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = '3-D Man'	superhero","SELECT attribute.attribute_name, hero_attribute.attribute_value FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE superhero.superhero_name = '3-D Man'",1,0,0,yellow,1,alias
"SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')	superhero","SELECT publisher.publisher_name FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE superhero.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')",1,0,0,yellow,1,alias
SELECT CAST(COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id	superhero,SELECT cast(sum(CASE WHEN colour.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / count(*) FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id,1,0,0,yellow,0,count is the same as sum since values are all 1
SELECT CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id	superhero,"SELECT cast(sum(iif(gender.gender = 'Male', 1, 0)) AS REAL) / sum(iif(gender.gender = 'Female', 1, 0)) FROM superhero INNER JOIN gender ON superhero.gender_id = gender.id",1,0,0,yellow,1, IIF = CASE WHEN
SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Karen Beecher-Duncan'	superhero,SELECT colour.colour FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id WHERE superhero.full_name = 'Karen Beecher-Duncan',1,0,0,yellow,1,alias
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Wind Control' ORDER BY T1.superhero_name	superhero,SELECT superhero.superhero_name FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Wind Control' ORDER BY superhero.superhero_name,1,0,0,yellow,1,alias
SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Phoenix Force'	superhero,SELECT gender.gender FROM gender INNER JOIN superhero ON gender.id = superhero.gender_id INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Phoenix Force',1,0,0,yellow,1,alias
SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id	superhero,SELECT sum(CASE WHEN publisher.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - sum(CASE WHEN publisher.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM publisher INNER JOIN superhero ON publisher.id = superhero.publisher_id,1,0,0,yellow,0,"superhero INNER JOIN publisher ON id 

is not logically equivalent to

publisher INNER JOIN superhero ON id"
"SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = ( SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') )	codebase_community",SELECT displayname FROM users WHERE displayname = 'Harlan' OR displayname = 'Jarrod Dixon' ORDER BY reputation DESC LIMIT 1,1,0,0,yellow,1,"IN is logicially equivalent to WHERE __ = ( __ or __ ... )

ORDER BY __ DESC 1 is logically equivelent to SELECT MAX(___) FROM ____"
"SELECT DisplayName FROM users WHERE STRFTIME('%Y', CreationDate) = '2011'	codebase_community","SELECT displayname FROM users WHERE strftime('%Y', creationdate) = '2011'",1,0,0,yellow,1,exact str match
SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'	codebase_community,SELECT users.displayname FROM posts INNER JOIN users ON posts.owneruserid = users.id WHERE posts.title = 'Eliciting priors from experts',1,0,0,yellow,1,alias
SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score >= 20 AND T2.Age > 65	codebase_community,SELECT count(posts.id) FROM users INNER JOIN posts ON users.id = posts.owneruserid WHERE users.age > 65 AND posts.score > 19,1,0,0,yellow,1,greater than or equal to 20 is logically equivalent to greater than 19
SELECT T2.Body FROM tags AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.ExcerptPostId WHERE T1.TagName = 'bayesian'	codebase_community,SELECT posts.body FROM tags INNER JOIN posts ON tags.excerptpostid = posts.id WHERE tags.tagname = 'bayesian',1,0,0,yellow,1,alias
"SELECT CAST(SUM(IIF(T2.Age > 65, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score > 5	codebase_community",SELECT cast(sum(CASE WHEN users.age > 65 THEN 1 ELSE 0 END) AS REAL) * 100 / count(*) FROM posts INNER JOIN users ON posts.owneruserid = users.id WHERE posts.score > 5,1,0,0,yellow,1, IIF = CASE WHEN
SELECT T1.DisplayName FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T2.Id = 6347	codebase_community,SELECT users.displayname FROM votes INNER JOIN users ON votes.userid = users.id WHERE votes.id = 6347,1,0,0,yellow,1,exact str match
SELECT Text FROM comments WHERE Score = 17	codebase_community,SELECT text FROM comments WHERE score = 17,1,0,0,yellow,1,exact str match
SELECT T1.DisplayName FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'thank you user93!'	codebase_community,SELECT users.displayname FROM comments INNER JOIN users ON comments.userid = users.id WHERE comments.text = 'thank you user93!',1,0,0,yellow,1,alias
SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'	codebase_community,SELECT users.displayname FROM posts INNER JOIN users ON posts.owneruserid = users.id WHERE posts.title = 'Open source tools for visualizing multi-dimensional data?',1,0,0,yellow,1,alias
SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'	codebase_community,SELECT posthistory.comment FROM posts INNER JOIN posthistory ON posts.id = posthistory.postid WHERE posts.title = 'Why square the difference instead of taking the absolute value in standard deviation?',1,0,0,yellow,1,alias
"SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes	codebase_community",SELECT cast(sum(CASE WHEN votes.creationdate LIKE '2010%' THEN 1 ELSE 0 END) AS REAL) / sum(CASE WHEN votes.creationdate LIKE '2011%' THEN 1 ELSE 0 END) FROM votes,1,0,0,yellow,1, IIF = CASE WHEN
SELECT T2.PostId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'slashnick' ORDER BY T3.AnswerCount DESC LIMIT 1	codebase_community,SELECT posts.id FROM users INNER JOIN posts ON users.id = posts.owneruserid WHERE users.displayname = 'slashnick' ORDER BY posts.answercount DESC LIMIT 1,1,0,0,yellow,1,alias
"SELECT CAST(COUNT(T1.Id) AS REAL) / 12 FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.AnswerCount <= 2 AND STRFTIME('%Y', T1.CreationDate) = '2010'	codebase_community","SELECT cast(count(postlinks.id) AS REAL) / 12 FROM posts INNER JOIN postlinks ON posts.id = postlinks.postid WHERE posts.answercount <= 2 AND strftime('%Y', postlinks.creationdate) = '2010'",1,0,0,yellow,1,Different join order
SELECT T2.CreationDate FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl' ORDER BY T2.CreationDate LIMIT 1	codebase_community,SELECT votes.creationdate FROM votes INNER JOIN users ON votes.userid = users.id WHERE users.displayname = 'chl' ORDER BY votes.creationdate ASC LIMIT 1,1,0,0,yellow,1,Different join order
SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1	codebase_community,SELECT users.displayname FROM users INNER JOIN badges ON users.id = badges.userid WHERE badges.name = 'Autobiographer' ORDER BY badges.date LIMIT 1,1,0,0,yellow,1,same syntax and logic
SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4	codebase_community,SELECT count(users.id) FROM users INNER JOIN posts ON users.id = posts.owneruserid WHERE users.location = 'United Kingdom' AND posts.favoritecount >= 4,1,0,0,yellow,1,same structure and conditions
"SELECT T2.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Harvey Motulsky' ORDER BY T2.ViewCount DESC LIMIT 1	codebase_community","SELECT posts.id, posts.title FROM users INNER JOIN posts ON users.id = posts.owneruserid WHERE users.displayname = 'Harvey Motulsky' ORDER BY posts.viewcount DESC LIMIT 1",1,0,0,yellow,1,identical conditions
SELECT COUNT(T2.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId GROUP BY T1.Id ORDER BY T1.Score DESC LIMIT 1	codebase_community,SELECT count(id) FROM comments WHERE postid = ( SELECT id FROM posts ORDER BY score DESC LIMIT 1 ),1,0,0,yellow,1,GROUP BY vs INNER JOIN
SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation	codebase_community,SELECT cast(sum(CASE WHEN score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / count(id) FROM posts WHERE owneruserid = ( SELECT id FROM users ORDER BY reputation DESC LIMIT 1 ),1,0,0,yellow,1,Explicit join vs simplified subquery
"SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'	codebase_community","SELECT excerptpostid, wikipostid FROM tags WHERE tagname = 'sample'",1,0,0,yellow,1,identical
"SELECT T2.Reputation, T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'fine, you win :)'	codebase_community","SELECT users.reputation, users.upvotes FROM users INNER JOIN comments ON users.id = comments.userid WHERE comments.text = 'fine, you win :)'",1,0,0,yellow,1,same structure and results
SELECT Text FROM comments WHERE PostId IN ( SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150 ) ORDER BY Score DESC LIMIT 1	codebase_community,SELECT comments.text FROM posts INNER JOIN comments ON posts.id = comments.postid WHERE posts.viewcount BETWEEN 100 AND 150 ORDER BY comments.score DESC LIMIT 1,1,0,0,yellow,1,INNER JOIN
"SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10	codebase_community",SELECT cast(sum(CASE WHEN users.upvotes = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / count(comments.id) FROM comments INNER JOIN users ON comments.userid = users.id WHERE comments.score BETWEEN 5 AND 10,1,0,0,yellow,1,IFF vs CASE
SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards	card_games,SELECT cast(sum(CASE WHEN bordercolor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / count(id) FROM cards,1,0,0,yellow,1,capitalization
SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1	card_games,SELECT cast(sum(CASE WHEN foreign_data.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / count(*) FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.isstoryspotlight = 1,1,0,0,yellow,1,alias and capitalization
SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'	card_games,SELECT count(id) FROM cards WHERE originaltype = 'Summon - Angel' AND subtypes != 'Angel',1,0,0,yellow,1,capitalization
SELECT id FROM cards WHERE duelDeck = 'a'	card_games,SELECT id FROM cards WHERE dueldeck = 'a',1,0,0,yellow,1,capitalization
SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Banned' AND T1.borderColor = 'white'	card_games,SELECT count(*) FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE legalities.status = 'Banned' AND cards.bordercolor = 'white',1,0,0,yellow,1,1. need cards.id to be not null (actually is PK so is okay)
SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'	card_games,SELECT count(*) FROM sets INNER JOIN set_translations ON sets.code = set_translations.setcode WHERE sets.block = 'Commander' AND set_translations.language = 'Portuguese (Brazil)',1,0,0,yellow,1,"1. need cards.id to be not null (actually is PK so is okay)
2. using alias okay"
SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'	card_games,SELECT foreign_data.name FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.language = 'French' AND cards.artist = 'Matthew D. Wilson' AND cards.layout = 'normal' AND cards.bordercolor = 'black' AND cards.types = 'Creature',1,0,0,yellow,1,1. need cards.uuid to be unique to prevent duplicate result rows when using join (actually is unique and not null so is okay here)
SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'	card_games,SELECT cast(sum(CASE WHEN cards.hascontentwarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / count(*) FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE legalities.status = 'Legal' AND legalities.format = 'commander',1,0,0,yellow,1,"1. need cards.id to be not null (actually is PK so is okay)
2. using alias okay"
SELECT language FROM foreign_data WHERE multiverseid = 149934	card_games,SELECT LANGUAGE FROM foreign_data WHERE multiverseid = 149934,1,0,0,yellow,1,1. capitalization does not matter for table columns
SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'	card_games,SELECT DISTINCT set_translations.language FROM sets INNER JOIN set_translations ON sets.code = set_translations.setcode WHERE sets.mcmname = 'Archenemy' AND sets.code = 'ARC',1,0,0,yellow,0,"distinct vs no distinct

1. need set_translations.language to be unique
2. need set_translations.setcode to be unique and a FK for sets.code
3. need sets.code to be unique"
"SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1	card_games",SELECT name FROM cards WHERE name = 'Serra Angel' OR name = 'Shrine Keeper' ORDER BY faceconvertedmanacost - convertedmanacost DESC LIMIT 1,1,0,0,yellow,0,"1. order by condition is wrong 
2. column in set equivalent to column=item1 or column=item2, ..."
SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'	card_games,SELECT count(*) FROM cards INNER JOIN set_translations ON cards.setcode = set_translations.setcode WHERE set_translations.translation = 'Hauptset Zehnte Edition' AND cards.artist = 'Adam Rex',1,0,0,yellow,1,"1. need cards.id to be not null (actually is PK so is okay)
2. using alias okay"
SELECT T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Eighth Edition' AND T2.language = 'Chinese Simplified'	card_games,SELECT set_translations.translation FROM sets INNER JOIN set_translations ON sets.code = set_translations.setcode WHERE sets.name = 'Eighth Edition' AND set_translations.language = 'Chinese Simplified',1,0,0,yellow,1,1. using alias okay
SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 100 AND T2.language = 'Italian'	card_games,SELECT count(sets.id) FROM sets INNER JOIN set_translations ON sets.code = set_translations.setcode WHERE set_translations.language = 'Italian' AND sets.basesetsize < 100,1,0,0,yellow,0,"1. where clause is wrong
2. need set_translations.translation to be not null"
SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'	card_games,SELECT foreign_data.flavortext FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.name = 'Ancestor''s Chosen' AND foreign_data.language = 'Italian',1,0,0,yellow,1,1. using alias okay
SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'	card_games,SELECT cast(sum(CASE WHEN cards.convertedmanacost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / count(cards.id) FROM cards INNER JOIN sets ON cards.setcode = sets.code WHERE sets.name = 'Coldsnap',1,0,0,yellow,1,1. using alias okay
"SELECT T.bond_type FROM ( SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1 ) AS T	toxicology",SELECT bond_type FROM bond GROUP BY bond_type ORDER BY count(bond_type) DESC LIMIT 1,1,0,0,yellow,0,"select from subquery vs subquery as standalone query (generally is okay)

1. order by is using wrong column
2. need bond.bond_id (actually PK, so is okay) and bond.bond_type to be not null"
"SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t	toxicology",SELECT label FROM molecule GROUP BY label ORDER BY count(label) DESC LIMIT 1,1,0,0,yellow,0,"1. difference in tables used (atoms table)
2. need where clause to filter atoms.element
3. order by is using wrong column
4. need molecule.molecule_id and molecule.label to be not null"
"SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t	toxicology",SELECT atom.element FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.label = '-' GROUP BY atom.element ORDER BY count(atom.element) LIMIT 1,1,0,0,yellow,0,"1. need molecule.molecule_id (actually is PK so is okay) to. be unique, not null
2. need atom.element to be not null
3. ascending is default order by order"
SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3	toxicology,SELECT DISTINCT atom.element FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.molecule_id = 'TR000' ORDER BY atom.element LIMIT 3,1,0,0,yellow,1,"1. need atom.molecule_id to be a FK for molecule.molecule_id
2. limit is executed after the select distinct keywords"
"SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'	toxicology","SELECT DISTINCT atom.element, molecule.label FROM molecule INNER JOIN atom ON molecule.molecule_id = atom.molecule_id WHERE molecule.molecule_id = 'TR060'",1,0,0,yellow,1,alias
SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'	toxicology,SELECT DISTINCT atom.element FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.molecule_id = 'TR004',1,0,0,yellow,1,INNER JOIN is ok here since molecule_id is a foreign key
SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'i'	toxicology,SELECT cast(count(connected.bond_id) AS REAL) / count(atom.atom_id) FROM atom INNER JOIN connected ON atom.atom_id = connected.atom_id WHERE atom.element = 'i',1,0,0,yellow,1,alias
SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'	toxicology,SELECT atom.element FROM atom INNER JOIN connected ON atom.atom_id = connected.atom_id WHERE connected.bond_id = 'TR144_8_19',1,0,0,yellow,1,alias
SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'	toxicology,SELECT atom.element FROM atom INNER JOIN connected ON atom.atom_id = connected.atom_id WHERE connected.bond_id = 'TR001_10_11',1,0,0,yellow,1,"alias, almost identical to 172"
SELECT CAST(COUNT( CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'	toxicology,SELECT cast(sum(CASE WHEN atom.element = 'cl' THEN 1 ELSE 0 END) AS REAL) * 100 / count(atom.atom_id) FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.label = '+',1,0,0,yellow,1,"SUM and COUNT are the same here. 

both use 1/0 to encode when element='cl' and when the entry is null
"
"WITH SubQuery AS (SELECT DISTINCT T1.atom_id, T1.element, T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR006') SELECT CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / (CASE WHEN COUNT(atom_id) = 0 THEN NULL ELSE COUNT(atom_id) END) AS ratio, label FROM SubQuery GROUP BY label	toxicology","SELECT cast(sum(CASE WHEN atom.element = 'h' THEN 1 ELSE 0 END) AS REAL) / count(atom.atom_id), molecule.label FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.molecule_id = 'TR006'",1,0,0,yellow,,
"SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t	toxicology",SELECT molecule.molecule_id FROM molecule INNER JOIN atom ON molecule.molecule_id = atom.molecule_id WHERE molecule.label = '-' GROUP BY molecule.molecule_id HAVING count(atom.atom_id) > 5,1,0,0,yellow,,
"SELECT T2.School, T1.AvgScrWrite FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'	california_schools","SELECT satscores.sname, avg(satscores.avgscrwrite) FROM schools INNER JOIN satscores ON schools.cdscode = satscores.cds WHERE schools.admfname1 = 'Ricci' AND schools.admlname1 = 'Ulrich' GROUP BY satscores.sname",1,0,0,yellow,0,school name is not a foreign key. satscors.sname is not guanteed to have the same entries as schools.School
"SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 6, 1	california_schools","SELECT schools.mailstreet, schools.school FROM satscores INNER JOIN schools ON satscores.cds = schools.cdscode ORDER BY satscores.avgscrmath DESC LIMIT 6, 1",1,0,0,yellow,1,alias
SELECT COUNT(DISTINCT T2.district_id)  FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A11 BETWEEN 6000 AND 10000	financial,SELECT count(district_id) FROM district WHERE a11 > 6000 AND a11 < 10000,1,0,0,yellow,1,INNER JOIN is ok here since district_id is  foreign key
SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000	financial,SELECT count(client.client_id) FROM client INNER JOIN district ON client.district_id = district.district_id WHERE district.a3 = 'north Bohemia' AND client.gender = 'M' AND district.a11 > 8000,1,0,0,yellow,1,alias
"SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1	financial",SELECT account.account_id FROM loan INNER JOIN account ON loan.account_id = account.account_id WHERE account.date LIKE '1993%' AND loan.duration > 12 ORDER BY loan.amount DESC LIMIT 1,1,0,0,yellow,1,alias
SELECT T1.A2 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.birth_date = '1976-01-29' AND T2.gender = 'F'	financial,SELECT district.a2 FROM client INNER JOIN district ON client.district_id = district.district_id WHERE client.gender = 'F' AND client.birth_date = '1976-01-29',1,0,0,yellow,1,alias and order
"SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000	financial","SELECT avg(district.a15) FROM district INNER JOIN account ON district.district_id = account.district_id WHERE strftime('%Y', account.date) >= '1997' AND district.a15 > 4000",1,0,0,yellow,1,alias